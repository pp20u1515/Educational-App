The goal of almost any real program is to transform data from one form to another. To read data, you need a place in the computer's memory where you can input information and store it.

\bold Where do variables live?

Computer memory can be thought of as a large shelf where each section (cell) can store 1 byte of information (and each cell has its own unique address). However, we can remove any divider in a section to create a free cell of the desired size. This is where an object comes into play.

An object is a portion of the computer's RAM that stores a value (some information) of a specific type. An object can be thought of as a "box" where we can place a value of the corresponding type (for example, it might not be just a box, but a container for waste sorting: glass, plastic, paper, etc.). When an object is created, a portion of memory is allocated for that object. Most objects you will work with in the C language are variables.

A variable is a named object (for convenience, we can give this object a name, and thus we get a variable).

\bold Basic data types

In C, an object stores information of a specific type (which is why each variable requires its own type). You might wonder why such complexity is necessary, and why we can't use a single data type for everything? The answer is that using object types allows the compiler to efficiently manage memory allocation for objects and optimize their usage. The compiler knows the size and structure of each object type, enabling it to effectively allocate, deallocate, and manage memory resources. Types are fundamental to any program: they tell us what our data means and what operations we can perform on that data.

If we imagine an object as a waste container, then the container type determines what kind of waste we can put in it and what it signifies (organic, glass, metal). The type also determines how we will process our waste (metal is processed one way, glass another, and paper is handled differently). And the compiler watches over us to ensure we don't try to melt paper or organic waste.

C has extensive type support. The language defines several primitive types (characters, integers, floating-point numbers, etc.) and provides mechanisms that allow us to define our own data types. 

Below are shown basic data types that we will encounter and work with in this course (there are more data types in C).

1. Integer Types
char - Character Type

    Size: 1 byte (8 bits)

    Range: -128 to 127 or 0 to 255 (depending on signedness)

    Usage: Stores ASCII characters or small integers

    Format Specifier: %c, %d

int - Basic Integer

    Size: 2 or 4 bytes (typically 4 bytes on modern systems)

    Range: -32,768 to 32,767 (2-byte) or -2,147,483,648 to 2,147,483,647 (4-byte)

    Usage: Most common integer type for general arithmetic

    Format Specifier: %d
short - Short Integer

    Size: 2 bytes (16 bits)

    Range: -32,768 to 32,767

    Usage: When memory conservation is important

    Format Specifier: %hd
long - Long Integer

    Size: 4 or 8 bytes (platform-dependent)

    Range: Larger than regular int

    Usage: Large numbers that exceed int range

    Format Specifier: %ld
long long - Very Long Integer (C99+)

    Size: 8 bytes (64 bits)

    Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

    Usage: Extremely large integers

    Format Specifier: %lld

2. Floating-Point Types
float - Single Precision

    Size: 4 bytes (32 bits)

    Precision: ~6-7 decimal digits

    Usage: General floating-point operations where precision isn't critical

    Format Specifier: %f
double - Double Precision

    Size: 8 bytes (64 bits)

    Precision: ~15-16 decimal digits

    Usage: Most common floating-point type, good balance of precision and performance

    Format Specifier: %lf

Void Type
void - Absence of Type

    Size: N/A (cannot create variables of type void)

    Usage:

        Function return type (function doesn't return anything)

        Function parameters (function takes no arguments)

        Generic pointers (void*)

\bold Void, what is this creature?

The void data type in C represents the absence of a specific type. There are two main uses for the void type (we'll learn more in the following topics):

    The void type is used in function declarations to indicate that the function does not return a value. For example, a function with a return type of void would be declared as follows: void myFunction(). This is useful for functions that perform actions or have side effects without producing a result.

    Additionally, void can be used to declare pointers that do not point to a specific type. Such pointers are often used in generic programming or as placeholders when the actual type is unknown or irrelevant.

Pointers and functions are discussed in detail in subsequent topics.

It's important to note that you cannot create variables of type void, and void cannot be used as a data type for variables or objects. Its primary purpose is to indicate the absence of a specific type or to specify that a function does not return a value.

\bold First look at variables

Data types are closely related to variables. For now, let's take a quick look at variables.
As we mentioned earlier, a variable is an object with a name. Before we can start using a variable, we need to create it somehow. To do this, we can declare a variable (allocate memory for the object):

c

int ourIntVariable;     // declare an integer variable
float ourFloatVariable; // declare a floating-point variable
char ourCharVariable;   // declare a character variable
// this code will NOT work because "void" cannot be used as a variable type
void ourVoidVariable;
c

What happens after we declare a variable? When a variable is declared, the compiler comes into play. It allocates a corresponding block in the computer's memory that will be used to store the values of that variable during program execution. Later, when the program is running, the processor takes over, executing the compiled code and manipulating the data stored in the allocated memory.

For example, let's assume that the variable ourVariable is assigned the memory cell at address 0x30893da94. During program execution, when the variable name ourVariable is encountered, the processor knows to look into the memory cell at address 0x30893da94.

In other words, we've attached a label with the variable's name to our shelf, and from now on, we will work with that label.