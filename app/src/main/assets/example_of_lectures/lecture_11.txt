In the C programming language, when you want to perform basic mathematical operations like addition and subtraction, you use arithmetic operators. These operators provide an easy way to perform addition, subtraction, multiplication, division, and finding the remainder. In this topic, you will explore the most common arithmetic operators in C and learn how to use them to perform fundamental mathematical calculations.

\bold Basic Arithmetic Operations

Let's start by understanding how to use arithmetic operators for basic math.

Addition (+):
Used to add two operands (values). It works with integers, floating-point numbers, and even characters.
    
c

int sum = 10 + 8;        // sum becomes 18
float pi = 3.14f + 5.0f; // pi becomes 8.14f
char letter = 'A' + 4;   // letter becomes 'E' (ASCII value 69)
c

Subtraction (-):
Used to subtract the second operand from the first.

c

int difference = 15 - 5;     // difference becomes 10
float result = 7.5f - 2.5f;  // result becomes 5.0f
c

Multiplication (*):
The multiplication operator (*) multiplies two values.

c

int product = 7 * 4;         // product becomes 28
float area = 5.5f * 3.0f;    // area becomes 16.5f
c

Division (/):
The division operator (/) divides one value by another. The result depends on the operand types:

    Integer division: When both operands are integers, the result is an integer (the fractional part is truncated).

    Floating-point division: When at least one operand is a floating-point number, the result is a floating-point value.

c

int quotient_one = 20 / 3;    // quotient_one becomes 6 (integer division)
float quotient_two = 20.0f / 3; // quotient_two becomes ~6.6667f (floating-point division)
c

Modulus (%):
The modulus operator (%) finds the remainder of a division between two integers.

c

int remainder = 16 % 3; // remainder becomes 1
c

    Important: The modulus operator can only be used with integer-type values (int, char, short, long).

\bold Arithmetic with Different Data Types

C supports various data types like integers (int) and floating-point numbers (float, double). You can use arithmetic operators with these different types, and the compiler handles implicit type conversion when necessary. However, it's important to understand how these conversions work.

Integers:
When performing arithmetic with integers, the result is an integer. C automatically truncates any fractional part that arises from division.

c

int first_num = 16;
int second_num = 3;
int addition = first_num + second_num;     // 19
int subtraction = first_num - second_num;  // 13
int multiplication = first_num * second_num; // 48
int division = first_num / second_num;     // Result is 5, not 5.333...
int remainder = first_num % second_num;    // 1
c

Floating-Point Numbers:
Floating-point numbers can represent decimal values with fractional parts. The result of an operation will also be a floating-point number.

c

float first_num = 16.0f;
float second_num = 3.0f;
float addition = first_num + second_num;       // 19.0f
float subtraction = first_num - second_num;    // 13.0f
float multiplication = first_num * second_num; // 48.0f
float division = first_num / second_num;       // Result is ~5.33333f
// int remainder = first_num % second_num;     // ERROR: invalid operands to binary % ('float' and 'float')
c

Mixed Types and Implicit Type Conversion:
When performing operations with mixed data types (e.g., int and float), C automatically performs implicit type conversion (also called type promotion) to make the types compatible. The general rule is that the "smaller" or less precise type is converted to the "larger" or more precise type of the other operand.

c

int first_num = 16;
float second_num = 3.0f;
float addition = first_num + second_num;       // 19.0f (int promoted to float)
float subtraction = first_num - second_num;    // 13.0f
float multiplication = first_num * second_num; // 48.0f
float division = first_num / second_num;       // Result is ~5.33333f (int promoted to float before division)
// int remainder = first_num % second_num;     // ERROR: invalid operands (% requires integers)
c
\bold Compound Assignment Operators (Shorthand Operators)

Compound assignment operators provide a concise way to combine an arithmetic operation with an assignment. They update the value of a variable in a single step.
Operator	Example	Equivalent To
+=	x += y;	x = x + y;
-=	x -= y;	x = x - y;
*=	x *= y;	x = x * y;
/=	x /= y;	x = x / y;
%=	x %= y;	x = x % y;

Example:

c

#include <stdio.h>

int main() {
    int a = 10;
    int b = 3;

    a += b; // a is now 13 (a = 10 + 3)
    b *= 2; // b is now 6 (b = 3 * 2)
    printf("%d\n", a); // Prints 13
    printf("%d\n", b); // Prints 6

    a += 2; // a is now 15 (a = 13 + 2)
    b -= 5; // b is now 1 (b = 6 - 5)
    printf("%d\n", a); // Prints 15
    printf("%d\n", b); // Prints 1

    return 0;
}
c

\bold Important Considerations and Caveats

Integer Division Truncation:
As mentioned, dividing two integers truncates the fractional part. This can lead to unexpected results if you are not careful.

c

int first_num = 20;
int second_num = 6;
float result = first_num / second_num; // result is 3.0f, not 3.333...f
c

Solution: Use an explicit type cast to force floating-point division.

c

int first_num = 20;
int second_num = 6;
float result = (float)first_num / second_num; // Result is ~3.33333f
c

Integer Overflow:
The range of values a variable can hold is limited by its data type. Overflow occurs when the result of an operation exceeds this maximum value. When it happens, the value "wraps around" according to the rules of the system, leading to unexpected and incorrect results.

c

#include <stdio.h>
#include <limits.h> // For INT_MAX

int main() {
    int num = INT_MAX;      // Maximum value for a 32-bit integer (e.g., 2147483647)
    int result = num + 1;   // Result becomes INT_MIN (e.g., -2147483648) due to overflow
    printf("%d\n", result);
    return 0;
}
c

To avoid overflow, choose data types large enough to accommodate your expected results (e.g., long long, unsigned long).

Floating-Point Precision:
While floating-point types provide precision for decimal calculations, they are not immune to limitations due to their binary representation. This can sometimes lead to subtle inaccuracies, especially with very small or very large numbers or repeated operations.

c

#include <stdio.h>
#include <math.h> // For fabsf (absolute value for floats)

int main() {
    float num = 0.1f;
    float sum = num + num + num;

    // Compare with a tolerance due to representation error
    if (fabsf(sum - 0.3f) < 0.0001f) {
        printf("Equal (within tolerance)\n");
    } else {
        printf("Not Equal\n"); // This is the likely output
        printf("Actual sum: %.10f\n", sum); // Shows the actual value, e.g., 0.3000000119
    }
    return 0;
}
c

    Surprisingly, the output of this code is often "Not Equal". This happens because the decimal value 0.1 cannot be represented exactly in binary floating-point format, leading to a small rounding error that accumulates with each operation. This is a fundamental concept in numerical computing. Using double can improve precision, but does not eliminate the issue entirely.

