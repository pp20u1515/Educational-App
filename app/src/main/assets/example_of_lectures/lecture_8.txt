In the realm of C programming, functions play a pivotal role in creating modular and organized code. Put simply, functions are like machines: you put something in (input), they process it, and something comes out (output). This topic will discuss input (passing input data to a function). Understanding how input data are passed to functions is crucial for effective program design. This topic delves into the various ways to pass input data to functions.
Parameters and Arguments in Functions

To avoid confusion, you first need to understand the basic terms:

    In C, a parameter is a variable declared in a function's prototype or header. This parameter signals the type and number of values that a function expects upon its call. It closely resembles a typical variable declaration (like int x) and operates as a regular, localized variable within the function. The main role of this parameter is to facilitate the passage of values from the calling point to the function.

    On the other hand, arguments are the actual values that a function receives when someone invokes it. These arguments match the defined parameters and the function uses them for computation within its body.

Here is an example of using parameters and arguments when writing functions in C:

c

#include <stdio.h>

void byValue(int num) { // Here is our parameter 'num'
    num = 10; // which is further used in our function.
}

int main() {
    int x = 5;
    byValue(x); // And here we are passing an argument to our function
    byValue(3); // we can pass the argument like this
    return 0;
}
c

You can pass any type of data to a function: variables, pointers, constants, arrays, structures, or any user data.

There are various ways to pass arguments to a function:

    passing by value;

    passing by pointer; (Translator's note: C does not have pass by reference like C++)

Now, let's consider each option in more detail.

\bold Passing by Value

Passing by value involves sending a copy of the argument's value to the function. This means that any changes made to the parameter inside the function do not affect the original argument outside of the function. This method is useful when working with the argument's value without altering the original data.

c

#include <stdio.h>

void byValue(int num) {
    num = 10; // Changes here won't affect the original value
    printf("%d", num);
}

int main() {
    int x = 5;
    byValue(x);
    printf("%d", x); // Outputs: 5
    return 0;
}
c

Output: 105 (Translator's note: In C, the printf function output does not include a newline by default, so the numbers appear consecutively. For readability, you can add spaces or newline characters \n)

In the example above, the function byValue takes an integer argument num and tries to modify it. However, since it's passed by value, the change is local to the function and doesn't affect the original value of x in the main function.

When passing by value, you "send" a copy of your object to the function. If you need to transfer a large amount of data (for example, an array of 1 million elements of a complex structure can weigh 1 GB), then this can be expensive and not optimal for your computer.

\bold Passing by Pointer

Passing by pointer involves sending the memory address of the argument to the function. This allows the function to access and modify the original value indirectly through the pointer. Pointers provide more control, as they can be reassigned to point to different memory locations.

(Translator's note: C does not have pass by reference (&) like C++. Instead, pointers are always used to modify original arguments or to avoid copying large data.)

To do this, declare the function parameter as a pointer (int *ptr), call the function by passing the address of the variable (byPointer(&x)). Or you can pass the value of the pointer itself.

c

#include <stdio.h>

void byPointer(int *ptr) {
    // in order to work with the value, not the address, we dereference the pointer
    *ptr = 10; // Changes here will affect the original value through the pointer
}

int main() {
    int x = 5;
    byPointer(&x); // passing the address of the variable.
    printf("%d", x); // Output: 10
    return 0;
}

Output: 10
c

In this example, the function byPointer takes an integer pointer as its argument. The pointer is dereferenced to access and modify the original value of x in the main function.

Working with pointers, whether in the context of arrays, functions, or memory management, offers great flexibility in programming. However, due to their direct manipulation of memory addresses, mishandling pointers can lead to memory corruption, crashes, and challenging debugging. It's crucial to grasp pointer-related concepts, initialize pointers properly, and follow best practices to prevent errors such as memory leaks and buffer overflows.

\bold Tips for Usage

    Use Pointer to Const for Data Protection: When you want to pass an argument without modifying it, pass a pointer to const data (e.g., const int *ptr) to prevent accidental changes. This is particularly useful for objects that are expensive to copy (big objects). This also serves as a form of documentation for other developers.

    Use Pointer for Modification: If a function needs to modify the argument, pass it by pointer to avoid unnecessary copying. This is the standard way in C to modify function arguments.

    Be Cautious with Pointers: Passing pointers requires careful memory management. Ensure that the pointer is valid and points to valid memory to avoid issues like null pointer dereferencing. Always check if a pointer is not NULL before dereferencing it inside a function if there is any chance it might be null.

    Document Your Code in Detail: Clearly document in your code comments whether functions modify arguments or not. This helps other developers understand how to use the functions correctly. This is especially important in C because the call for functions that expect a value (byValue(x)) or a pointer (byPointer(&x)) looks different, and this distinction must be understood. Always clearly state in the function documentation whether it expects a pointer (and if it will dereference and modify the data) and who is responsible for the memory it points to.