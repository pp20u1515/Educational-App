{
  "id": "11",
  "title": "Arithmetic Operations",
  "content": "In the C programming language, when you want to perform basic mathematical operations like addition and subtraction, you use arithmetic operators. These operators provide an easy way to perform addition, subtraction, multiplication, division, and finding the remainder. In this topic, you will explore the most common arithmetic operators in C and learn how to use them to perform fundamental mathematical calculations.\n\n\\bold Basic Arithmetic Operations\n\nLet's start by understanding how to use arithmetic operators for basic math.\n\nAddition (+):\nUsed to add two operands (values). It works with integers, floating-point numbers, and even characters.\n    \nc\n\nint sum = 10 + 8;        // sum becomes 18\nfloat pi = 3.14f + 5.0f; // pi becomes 8.14f\nchar letter = 'A' + 4;   // letter becomes 'E' (ASCII value 69)\nc\n\nSubtraction (-):\nUsed to subtract the second operand from the first.\n\nc\n\nint difference = 15 - 5;     // difference becomes 10\nfloat result = 7.5f - 2.5f;  // result becomes 5.0f\nc\n\nMultiplication (*):\nThe multiplication operator (*) multiplies two values.\n\nc\n\nint product = 7 * 4;         // product becomes 28\nfloat area = 5.5f * 3.0f;    // area becomes 16.5f\nc\n\nDivision (/):\nThe division operator (/) divides one value by another. The result depends on the operand types:\n\n    Integer division: When both operands are integers, the result is an integer (the fractional part is truncated).\n\n    Floating-point division: When at least one operand is a floating-point number, the result is a floating-point value.\n\nc\n\nint quotient_one = 20 / 3;    // quotient_one becomes 6 (integer division)\nfloat quotient_two = 20.0f / 3; // quotient_two becomes ~6.6667f (floating-point division)\nc\n\nModulus (%):\nThe modulus operator (%) finds the remainder of a division between two integers.\n\nc\n\nint remainder = 16 % 3; // remainder becomes 1\nc\n\n    Important: The modulus operator can only be used with integer-type values (int, char, short, long).\n\n\\bold Arithmetic with Different Data Types\n\nC supports various data types like integers (int) and floating-point numbers (float, double). You can use arithmetic operators with these different types, and the compiler handles implicit type conversion when necessary. However, it's important to understand how these conversions work.\n\nIntegers:\nWhen performing arithmetic with integers, the result is an integer. C automatically truncates any fractional part that arises from division.\n\nc\n\nint first_num = 16;\nint second_num = 3;\nint addition = first_num + second_num;     // 19\nint subtraction = first_num - second_num;  // 13\nint multiplication = first_num * second_num; // 48\nint division = first_num / second_num;     // Result is 5, not 5.333...\nint remainder = first_num % second_num;    // 1\nc\n\nFloating-Point Numbers:\nFloating-point numbers can represent decimal values with fractional parts. The result of an operation will also be a floating-point number.\n\nc\n\nfloat first_num = 16.0f;\nfloat second_num = 3.0f;\nfloat addition = first_num + second_num;       // 19.0f\nfloat subtraction = first_num - second_num;    // 13.0f\nfloat multiplication = first_num * second_num; // 48.0f\nfloat division = first_num / second_num;       // Result is ~5.33333f\n// int remainder = first_num % second_num;     // ERROR: invalid operands to binary % ('float' and 'float')\nc\n\nMixed Types and Implicit Type Conversion:\nWhen performing operations with mixed data types (e.g., int and float), C automatically performs implicit type conversion (also called type promotion) to make the types compatible. The general rule is that the \"smaller\" or less precise type is converted to the \"larger\" or more precise type of the other operand.\n\nc\n\nint first_num = 16;\nfloat second_num = 3.0f;\nfloat addition = first_num + second_num;       // 19.0f (int promoted to float)\nfloat subtraction = first_num - second_num;    // 13.0f\nfloat multiplication = first_num * second_num; // 48.0f\nfloat division = first_num / second_num;       // Result is ~5.33333f (int promoted to float before division)\n// int remainder = first_num % second_num;     // ERROR: invalid operands (% requires integers)\nc\n\\bold Compound Assignment Operators (Shorthand Operators)\n\nCompound assignment operators provide a concise way to combine an arithmetic operation with an assignment. They update the value of a variable in a single step.\nOperator\tExample\tEquivalent To\n+=\tx += y;\tx = x + y;\n-=\tx -= y;\tx = x - y;\n*=\tx *= y;\tx = x * y;\n/=\tx /= y;\tx = x / y;\n%=\tx %= y;\tx = x % y;\n\nExample:\n\nc\n\n#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int b = 3;\n\n    a += b; // a is now 13 (a = 10 + 3)\n    b *= 2; // b is now 6 (b = 3 * 2)\n    printf(\"%d\\n\", a); // Prints 13\n    printf(\"%d\\n\", b); // Prints 6\n\n    a += 2; // a is now 15 (a = 13 + 2)\n    b -= 5; // b is now 1 (b = 6 - 5)\n    printf(\"%d\\n\", a); // Prints 15\n    printf(\"%d\\n\", b); // Prints 1\n\n    return 0;\n}\nc\n\n\\bold Important Considerations and Caveats\n\nInteger Division Truncation:\nAs mentioned, dividing two integers truncates the fractional part. This can lead to unexpected results if you are not careful.\n\nc\n\nint first_num = 20;\nint second_num = 6;\nfloat result = first_num / second_num; // result is 3.0f, not 3.333...f\nc\n\nSolution: Use an explicit type cast to force floating-point division.\n\nc\n\nint first_num = 20;\nint second_num = 6;\nfloat result = (float)first_num / second_num; // Result is ~3.33333f\nc\n\nInteger Overflow:\nThe range of values a variable can hold is limited by its data type. Overflow occurs when the result of an operation exceeds this maximum value. When it happens, the value \"wraps around\" according to the rules of the system, leading to unexpected and incorrect results.\n\nc\n\n#include <stdio.h>\n#include <limits.h> // For INT_MAX\n\nint main() {\n    int num = INT_MAX;      // Maximum value for a 32-bit integer (e.g., 2147483647)\n    int result = num + 1;   // Result becomes INT_MIN (e.g., -2147483648) due to overflow\n    printf(\"%d\\n\", result);\n    return 0;\n}\nc\n\nTo avoid overflow, choose data types large enough to accommodate your expected results (e.g., long long, unsigned long).\n\nFloating-Point Precision:\nWhile floating-point types provide precision for decimal calculations, they are not immune to limitations due to their binary representation. This can sometimes lead to subtle inaccuracies, especially with very small or very large numbers or repeated operations.\n\nc\n\n#include <stdio.h>\n#include <math.h> // For fabsf (absolute value for floats)\n\nint main() {\n    float num = 0.1f;\n    float sum = num + num + num;\n\n    // Compare with a tolerance due to representation error\n    if (fabsf(sum - 0.3f) < 0.0001f) {\n        printf(\"Equal (within tolerance)\\n\");\n    } else {\n        printf(\"Not Equal\\n\"); // This is the likely output\n        printf(\"Actual sum: %.10f\\n\", sum); // Shows the actual value, e.g., 0.3000000119\n    }\n    return 0;\n}\nc\n\n    Surprisingly, the output of this code is often \"Not Equal\". This happens because the decimal value 0.1 cannot be represented exactly in binary floating-point format, leading to a small rounding error that accumulates with each operation. This is a fundamental concept in numerical computing. Using double can improve precision, but does not eliminate the issue entirely.\n\n",
  "isCompleted": true,
  "practice": null
}