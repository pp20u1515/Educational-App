{
  "id": "4",
  "title": "Data Structure and Types",
  "content": "The goal of almost any real program is to transform data from one form to another. To read data, you need a place in the computer's memory where you can input information and store it.\n\n\\bold Where do variables live?\n\nComputer memory can be thought of as a large shelf where each section (cell) can store 1 byte of information (and each cell has its own unique address). However, we can remove any divider in a section to create a free cell of the desired size. This is where an object comes into play.\n\nAn object is a portion of the computer's RAM that stores a value (some information) of a specific type. An object can be thought of as a \"box\" where we can place a value of the corresponding type (for example, it might not be just a box, but a container for waste sorting: glass, plastic, paper, etc.). When an object is created, a portion of memory is allocated for that object. Most objects you will work with in the C language are variables.\n\nA variable is a named object (for convenience, we can give this object a name, and thus we get a variable).\n\n\\bold Basic data types\n\nIn C, an object stores information of a specific type (which is why each variable requires its own type). You might wonder why such complexity is necessary, and why we can't use a single data type for everything? The answer is that using object types allows the compiler to efficiently manage memory allocation for objects and optimize their usage. The compiler knows the size and structure of each object type, enabling it to effectively allocate, deallocate, and manage memory resources. Types are fundamental to any program: they tell us what our data means and what operations we can perform on that data.\n\nIf we imagine an object as a waste container, then the container type determines what kind of waste we can put in it and what it signifies (organic, glass, metal). The type also determines how we will process our waste (metal is processed one way, glass another, and paper is handled differently). And the compiler watches over us to ensure we don't try to melt paper or organic waste.\n\nC has extensive type support. The language defines several primitive types (characters, integers, floating-point numbers, etc.) and provides mechanisms that allow us to define our own data types. \n\nBelow are shown basic data types that we will encounter and work with in this course (there are more data types in C).\n\n1. Integer Types\nchar - Character Type\n\n    Size: 1 byte (8 bits)\n\n    Range: -128 to 127 or 0 to 255 (depending on signedness)\n\n    Usage: Stores ASCII characters or small integers\n\n    Format Specifier: %c, %d\n\nint - Basic Integer\n\n    Size: 2 or 4 bytes (typically 4 bytes on modern systems)\n\n    Range: -32,768 to 32,767 (2-byte) or -2,147,483,648 to 2,147,483,647 (4-byte)\n\n    Usage: Most common integer type for general arithmetic\n\n    Format Specifier: %d\nshort - Short Integer\n\n    Size: 2 bytes (16 bits)\n\n    Range: -32,768 to 32,767\n\n    Usage: When memory conservation is important\n\n    Format Specifier: %hd\nlong - Long Integer\n\n    Size: 4 or 8 bytes (platform-dependent)\n\n    Range: Larger than regular int\n\n    Usage: Large numbers that exceed int range\n\n    Format Specifier: %ld\nlong long - Very Long Integer (C99+)\n\n    Size: 8 bytes (64 bits)\n\n    Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n\n    Usage: Extremely large integers\n\n    Format Specifier: %lld\n\n2. Floating-Point Types\nfloat - Single Precision\n\n    Size: 4 bytes (32 bits)\n\n    Precision: ~6-7 decimal digits\n\n    Usage: General floating-point operations where precision isn't critical\n\n    Format Specifier: %f\ndouble - Double Precision\n\n    Size: 8 bytes (64 bits)\n\n    Precision: ~15-16 decimal digits\n\n    Usage: Most common floating-point type, good balance of precision and performance\n\n    Format Specifier: %lf\n\nVoid Type\nvoid - Absence of Type\n\n    Size: N/A (cannot create variables of type void)\n\n    Usage:\n\n        Function return type (function doesn't return anything)\n\n        Function parameters (function takes no arguments)\n\n        Generic pointers (void*)\n\n\\bold Void, what is this creature?\n\nThe void data type in C represents the absence of a specific type. There are two main uses for the void type (we'll learn more in the following topics):\n\n    The void type is used in function declarations to indicate that the function does not return a value. For example, a function with a return type of void would be declared as follows: void myFunction(). This is useful for functions that perform actions or have side effects without producing a result.\n\n    Additionally, void can be used to declare pointers that do not point to a specific type. Such pointers are often used in generic programming or as placeholders when the actual type is unknown or irrelevant.\n\nPointers and functions are discussed in detail in subsequent topics.\n\nIt's important to note that you cannot create variables of type void, and void cannot be used as a data type for variables or objects. Its primary purpose is to indicate the absence of a specific type or to specify that a function does not return a value.\n\n\\bold First look at variables\n\nData types are closely related to variables. For now, let's take a quick look at variables.\nAs we mentioned earlier, a variable is an object with a name. Before we can start using a variable, we need to create it somehow. To do this, we can declare a variable (allocate memory for the object):\n\nc\n\nint ourIntVariable;     // declare an integer variable\nfloat ourFloatVariable; // declare a floating-point variable\nchar ourCharVariable;   // declare a character variable\n// this code will NOT work because \"void\" cannot be used as a variable type\nvoid ourVoidVariable;\nc\n\nWhat happens after we declare a variable? When a variable is declared, the compiler comes into play. It allocates a corresponding block in the computer's memory that will be used to store the values of that variable during program execution. Later, when the program is running, the processor takes over, executing the compiled code and manipulating the data stored in the allocated memory.\n\nFor example, let's assume that the variable ourVariable is assigned the memory cell at address 0x30893da94. During program execution, when the variable name ourVariable is encountered, the processor knows to look into the memory cell at address 0x30893da94.\n\nIn other words, we've attached a label with the variable's name to our shelf, and from now on, we will work with that label.",
  "isCompleted": true,
  "practice": null
}