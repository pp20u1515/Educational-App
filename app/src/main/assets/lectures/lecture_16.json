{
  "id": "16",
  "title": "Structures",
  "content": "You already know how to store individual data (variables) and collections of homogeneous data (arrays). But what if you want to store different types of data under one roof? That's where structures come into play in C. Structures allow you to store heterogeneous types of data together, providing a unified container for them. They provide a way to organize related data elements and create more complex data structures.\n\n\\bold Why do you need structures?\n\nLet's explore some of the key reasons why you need structures:\n\n    Grouping Related Data: Structures allow you to group related data together. For example, if you are working with a student record that consists of attributes like name, age, and grade, you can create a structure that encapsulates all these attributes into a single entity. This makes it easier to manage and manipulate related data as a cohesive unit.\n\n    Creating User-Defined Data Types: Structures enable you to define your own data types based on your specific requirements. By defining a structure, you can create a custom data type that holds a collection of different variables. This allows you to create meaningful abstractions and represent real-world entities in our programs.\n\n    Passing Complex Data to Functions: Structures provide a convenient way to pass complex data to functions. Instead of passing multiple individual parameters, you can pass a structure that encapsulates all the necessary data.\n\n\\bold Structure declaration\n\nYou need to inform the compiler about the structure's design (so to speak, provide a blueprint). For this purpose, use the keyword struct in C. It is followed by the structure name and a block of variables that define its members. Each member can have a different data type and represents a specific attribute of the structure.\nc\n\nstruct Person {\n    char name[50];\n    int age;\n    float height;\n};\nc\nIn C, the structure definition is a statement, and like any other statement, you need to terminate it with a semicolon.\nKeep in mind that this requirement for a semicolon applies not only to structure definitions but to other statements as well:\n\n    such as variable declarations\n\n    function declarations\n\n    function calls.\n    Note that the ; after } is very important in the context of structures.\n\n\\bold Accessing structure members\n\nTo use the Person struct, you simply need to declare a variable of type struct Person. And after that, you can access structure members using the dot (.) operator.\n\nAn operator is a symbol or keyword used to perform specific operations on variables or values, such as addition or comparison. In C, the dot operator (.) is used to access members (variables) of an object or structure. Just remember this information: you don't need to focus on it right now as we will cover all operators in the next topics.\n\nThis allows you to retrieve or modify the values of individual members of a structure.\nc\n\nstruct Person mike;\nstrcpy(mike.name, \"Mike Wazowski\"); // In C, use strcpy for strings\nmike.age = 45;\nmike.height = 1.2;\n\nstruct Person james;\nstrcpy(james.name, \"James P. Sullivan\");\njames.age = 47;\njames.height = 2.2;\nc\n\\bold Struct initialization\n\nYou can initialize the structure by accessing each member individually (as in the example above) or by using a compound literal (C99 and later):\nc\n\n// Method 1: Upon declaration (initializer list)\nstruct Person mike = { \"Mike Wazowski\", 45, 1.2 };\n\n// Method 2: Using a compound literal (C99)\nstruct Person james = { .name = \"James P. Sullivan\", .age = 47 }; // You can initialize specific fields\n// For james.height, the default value (0) will be used\n\n// Assignment using a compound literal after declaration (C99)\nstruct Person mike;\nmike = (struct Person) { \"Mike Wazowski\", 45, 1.2 };\nc\n\nIf one or more elements are not in the initializer list (like james.height in the first example), then they will be assigned default values (usually 0). In the example above, the james.height member is set to the default value of 0 because you didn't provide any value yourself during initialization.\n\n\\bold Nested structures\n\nYou can nest structures within other structures, which allows you to create more complex data structures. This helps in organizing related data and maintaining a logical structure.\nc\n\n#include <string.h> // For strcpy\n\nstruct Address {\n    char street[50];\n    char city[50];\n    char country[50];\n};\n\nstruct Employee {\n    char name[50];\n    int age;\n    struct Address address; // Nested structure\n};\n\nstruct Company {\n    char name[50];\n    struct Employee CEO;\n    struct Address address;\n};\nc\nNow you can work with information in a convenient, and, most importantly, structured and understandable way:\nc\n\nstruct Company comp;\nstrcpy(comp.CEO.name, \"John Doe\");\nstrcpy(comp.CEO.address.street, \"Main St. 123\"); // getting the CEO's street\nstrcpy(comp.address.street, \"Broadway 456\"); // and this is the street where the company is located\nc\n\\bold Using structures in functions\n\nStructures can be passed as function arguments or returned from functions. This allows you to avoid passing each variable individually. Moreover, if you ever want to add new members to the Person structure, you don't have to modify the function declaration or call (we will introduce the concept of functions very soon, and we hope this example is fairly simple and understandable):\nc\n\n#include <stdio.h>\n#include <string.h> // For strcpy\n\n// Define the Person structure\nstruct Person {\n    char name[50];\n    int age;\n    float height;\n};\n\n// Function to print information about a person\n// Note: the structure is passed by value (a copy is created)\nvoid printPersonInformation(struct Person person) {\n    printf(\"Name: %s\\n\", person.name);\n    printf(\"Age: %d\\n\", person.age);\n    printf(\"Height: %.1f\\n\\n\", person.height);\n}\n\nint main() {\n    // Initialize structures\n    struct Person mike = { \"Mike Wazowski\", 45, 1.2 };\n    struct Person james = { \"James P. Sullivan\", 47, 2.2};\n\n    printPersonInformation(mike); // Display information about Mike\n    printPersonInformation(james); // Display information about James\n\n    return 0;\n}\nc\nWe haven't covered functions in detail yet, but for the purpose of understanding the code, here's a brief explanation:\nA function is a distinct block of code enclosed in curly braces {} and assigned a name. It serves as a reusable unit of code, which is beneficial when you need to execute the same logic multiple times.\nIn this code, we created a function named printPersonInformation. Inside the function, we simply output data about the structure passed as an argument.\nIn the main function, we call (use) the printPersonInformation function multiple times (specifically, twice), passing different structures to it. This approach allows us to write the logic only once and then easily reuse it in the future.\nYou will delve into functions more comprehensively later on.\n\n\uD83D\uDCA1 Structures are very important in the C language because understanding them is the first big step towards structured and modular programming! Later you will explore other concepts, such as pointers to structures and passing structures by reference (via pointers).",
  "isCompleted": true,
  "practice": null
}